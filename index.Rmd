---
title: Introduction to geoscripting
author: "Jan Verbesselt, Loïc Dutrieux and Dainius Masiliūnas"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  knitrBootstrap::bootstrap_document:
    title: "Week 1, Lesson 1: Introduction to the geo-scripting course"
    theme: "simplex"
    highlight: Tomorrow Night Bright
    menu: FALSE
    theme.chooser: TRUE
    highlight.chooser: TRUE
---

# [WUR Geoscripting](https://geoscripting-wur.github.io/) <img src="http://www.wur.nl/upload/b43b7095-e452-482a-8969-fed9a50393a8_WUR_RGB_standard.png" alt="WUR logo" style="height: 35px;"/>

# Week 1, Lesson 1: Introduction to the geo-scripting 

Good morning, and welcome to the Geo-scripting course! As a student enrolled in the course at Wageningen University, here is what you will do today:

- Morning: 
    - **Self-study** (working at home/or PC's at WUR): go through the tutorial below.
    - Answer the questions mentioned in **bold** in green boxes within the self-study section.
- 14:00: 
    - Participate in the course introduction and planning lecture ([location of the PC lab](https://ssc.wur.nl/Handbook/CourseSchedule/GRS-33806)).
    - Select your teammate and come up with a team name.
    - Do the exercise at the bottom of this page, with submission deadline today.

## *To Do* in the morning: self-study

You need to complete before 13h today:

- See information provided via blackboard in the section course description: lesson 1! 
You need to have *R* and an R GUI such as *RStudio Desktop* installed on your personal computer. Or work from a Wageningen University PC where this should normally be available. Throughout this course, we will be using free and open-source software.

- For more information about *R* and *RStudio* installation: see the [RStudio website](https://www.rstudio.com/products/rstudio/download/).

- If you have questions you can use the [Question and Answer Website of the Geo-scripting course](http://www.geo-informatie.nl/courses/grs33806/question2answer/), or for peer support, the [Slack channel for Geoscripting of the current year](https://wur-grs.slack.com/messages/CER16SCFL).
**Try to register and then ask or answer a question today.** We will explain how this can be used today.

```{block type="alert alert-info"}
**Note for external students:** if you are taking the course externally, see the [Geo-scripting system set-up](http://geoscripting-wur.github.io/system_setup/) page for instructions on how to set up all the software needed for the course.
```

## Objective and Learning outcomes of today:

- Refresh R skills and assessing scripting skills to see if you have the 
necessary scripting skills to continue with the course
- Learn to write a function
- Know how to visualize data via a spatial map using an R script

# Basic *R* and *RStudio* setup {#gettingstarted}

This preliminary section will cover some basic details about *R*. For this course you can use RStudio to write and run scripts.
In case you are working on your own computer and would like to know how to install *R* and *RStudio*, see the [RStudio website](https://www.rstudio.com/products/rstudio/download/).


```{block type="alert alert-info"}
**Protip**: if you are following the course externally, you can also set up all the rest of the necessary software for the course now. See the [system setup page](https://geoscripting-wur.github.io/system_setup/) for instructions. This is not necessary for enrolled students, as all the software will be provided in the upcoming lessons.
```

## Getting started with *RStudio* and *R* on your own computer.

A summary YouTube movie about how to use RStudio and writing a function is here: [Intro to RStudio](https://www.youtube.com/watch?v=jPk6-3prknk). Have a look at this movie if you do not know how to work with RStudio and then do the following section. See the following tutorial for a [short introduction on the RStudio interface](http://cran.r-project.org/doc/contrib/Torfs+Brauer-Short-R-Intro.pdf).

Now, Open RStudio and type the following script in the R console of **RStudio**:

```{r}
a <- 1
a
```

The first line you passed to the console created a new object named  $a$ in memory.
The symbol `<-` is somewhat equivalent to an equals sign `=` for assigning values to variables. In the second line you printed $a$ to the console by simply typing its name.

**What is the class of this object?**

```{r}
class(a)
```

You now have requested the class attribute of $a$ and the console has returned the attribute: numeric. R possesses a simple mechanism to support an object-oriented style of programming. All objects ($a$ in this case) have a class attribute assigned to them. R is quite forgiving and will assign a class to an object even if you haven't specified one (as you didn't in this case). Classes are a very important feature of the R environment. Any function or method that is applied to an object takes into account its class and uses this information to determine the correct course of action.

## Set Your Working Directory

Let's do some basic set up first.

- Create a folder which will be your working directory e.g. `Lesson1`
- Create an R script within that folder
- Set your working directory to the `Lesson1` folder
- Create a `data` folder within your working directory

In RStudio you can set your working directory this way, if you have saved your R script to your working directory:
![](figs/setwd_rstudiotip.png)

```{block, type="alert alert-danger"}
**Warning**: The use of `setwd()` is not a good practice in scripts without a very, very good reason. The users are aware of the environment and working directories and scripts should not try to outsmart the users.

*Never set the following in your script! This would make the script not reproducible by others!*
`setwd('some/path/on/your/computer')`
```



```{block type="alert alert-info"}
**Protip**: You can use relative paths to load your data. 
For example by setting the path to a 
file "my-table.csv" in the directory "data", relative to your script file:
`datafile <- file.path("data", "my-table.csv")`

Then you can for example read in the file using:
`mytable <- read.csv(datafile) # Do something with that file name`

```

The above Protip is very important, so make sure you understand this and use this 
within the geo-scripting exercises.

# Basic *R* knowledge useful for Geo-Scripting
Scripting with *R* to handle spatial problems requires a core set of basic *R* skills. To prepare you well for the coming weeks, we've summarized what we think are important skills for geo-scripting below. 

## Vector handling and vector arithmetic
**In *R* we call a one-dimensional array of values a *vector*, and a two-dimensional array of values a *matrix*.**

This can be a bit confusing, because R vectors have nothing to do with vectors as you know them in GIS. The latter will be introduced in a later lesson. You'll also be introduced in a following lesson with the *raster* package and the `raster` classes that have been developed as part of that package. Since rasters are 2D grids of values, all objects that belong to the class `raster` are **matrices** with a few more spatial attributes.

As a consequence, handling vectors and matrices is a crucial skill for processing raster data in *R*.

Reference manual for vector handling and vector arithmetic can be found [here](http://cran.r-project.org/doc/manuals/r-release/R-intro.html#Simple-manipulations-numbers-and-vectors).

```{r}
# Create a vector
a <- c(3,6,8,1)
a

# Any mathematical operation can be performed on vectors
(b <- a * 2)
(d <- a + 6)

# Two vectors of same length can also be added with each other
(e <- a + b)

# It works even if their lengths differ, in which case values are "recycled"
(f <- a + b[1:2])
```

Vectors of numbers are called **numeric vectors**, and matrices of numbers are **numeric matrices**. Calculations with matrices work the same way as with vectors, i.e. element-wise. So a multiplication between two matrices is element-wise value multiplication, *not* mathematical matrix multiplication.

### Value replacement

```{r}
## Values in a vector that satisfy a certain condition can be replaced by other values
a <- c(2,5,2,5,6,9,2,12)

## Values inferior or equal to 5 are replaced by 0
a[a <= 5] <- 0
a

## Condition can be defined using another vector of equal length
a <- c(2,5,2,5,6,9,2,12)
b <- c(1,1,0,1,0,0,1,0)

## Change the values of a based on b values
a[b == 0] <- NA
a
```

More complex value replacement:

```{r}
a <- c(2,5,2,5,6,9,2,12)
b <- c(1,1,2,1,0,0,1,2)
## a values at which b is equal to either 0 or 1 are replaced by NA
a[b %in% c(0,1)] <- NA
a
```

```{block, type="alert alert-success"}
> **Question 1:** How do I replace values in `b` by 3 at which `a` is 6, 9 and 12?
```

## Character vector handling

When working with real data, such as satellite imagery or KML files, the data always needs to be read from files. File names and file paths define the location of a file on a computer hard drive. A great advantage of scripting is that locating data, reading and writing data can be fairly easily automated (generate automatic file names, recognize patterns in file names, etc). That requires from the user some basic **character vector** (string) handling skills.

Key functions for handling character strings are listed below:

* `list.files()`: to list files in a directory.
* `glob2rx()`: to select files using a wildcard. Note: if you know regular expressions, you do not need that function. But most people are more comfortable working with wildcards.
* `paste()`, `paste0()`, `sprintf()`: useful to combine vectors e.g. to create a file name.
* `strsplit()`: to split up a string.

### Example of `list.files()`

```{r, eval=FALSE}
getwd() # check your working directory
list.files() # list the files available in this directory
```

```{block, type="alert alert-success"}
> **Question 2**: List the *directories* in your working directory.
```

### Example of `glob2rx()`

```{r, eval=FALSE}
## List all .txt files in working directory
list.files(getwd(), pattern = glob2rx("*.txt"))
```

### Example of `paste()` and `paste0()`

```{r}
## two handy examples
paste("Today is", date())
paste0("A", 1:6)
```

```{block, type="alert alert-success"}
> **Question 3**: Create one variable containing a sentence `"geo-scripting is fun"`, by combining `a`, `b`, and `c`:
```

```{r, eval=FALSE}
a <- "geo-scripting"
b <- "is"
c <- "fun"
```

```{r, echo=FALSE, eval=FALSE}
## what if you only have d, defined as a list?
d <- list(a, b, c)
paste(d) ## this is not good
```

### Example of `strsplit()`

```{r}
# I have the following character string
name <- 'today_is_friday_12-12-2014'

# I want to extract the date contained in it, I can split it based on the underscores and the fourth element should be the date
date0 <- unlist(strsplit('today_is_friday_12-12-2014', split = '_'))[4]

# Which can then be formatted as a date object (until now it is a character string)
class(date0)
(date <- as.Date(date0, format = '%m-%d-%Y'))
class(date)
```

```{block, type="alert alert-success"}
> **Question 4**: How do we select friday from the `name` variable?
```

See also `?substr`, this can be handy too.

## Reading and writing data

In the following lessons we will show you how you can read and write different spatial objects (e.g. vector and raster files).

Here, an example is given how you can read (import into *R*) and write a text file (i.e. export from *R*).

The most common way to read in spread sheet tables is with the `read.csv()` command.
However you can read in virtually any type of text file. Type `?read.table` in your console for some other examples.

```{r, eval=TRUE}
# getwd() ## Check your working directory
(test <- c(1:5, "6,7", "8,9,10"))
write.csv(test, file = "testing.csv") # Write to your working directory
rm(test) # Remove the variable "test" from the R working environment
ls() # Check that the object is no longer in the working environment
(test = read.csv("testing.csv")) # Read from your working directory
```

## Writing a function

It is hard to unleash the full potential of R without writing your own functions. Luckily it's very easy to do. Here are some trivial examples:

```{r}
## Put the function arguments in () and the evaluation in {}
add <- function(x){
  x + 1
}
add(4)
```

Set the default argument values for your function:

```{r}
add <- function(x = 5) {
  z <- x + 1
  return(z)
}
add()
add(6)
```

That's about all there is to it. The function will generally return the result of the last line that was evaluated.

```{block, type="alert alert-success"}
> **Question 5**: How do you write a function that returns `x` and `z`?
```

Now, let's declare a new object, a new function, `newfunc` (this is just a name and if you like you can give this function another name). Appearing in the first set of brackets is an argument list that specifies (in this case) two names. The value of the function appears within the second set of brackets where the process applied to the named objects from the argument list is defined.

```{r}
newfunc <- function(x, y) {
  z <- 2*x + y
  return(c(z,x,y))
}
a2b <- newfunc(2, 4)
a2b
```

Next, a new object `a2b` is created which contains the result of applying `newfunc` to the two objects you have defined earlier. The second last R command prints this new object to the console. Finally, you can now remove the objects you have created to make room for the next exercise by selecting and running the last line of the code.

```{r, eval=FALSE}
rm(a, newfunc, a2b)
```

## Creating a map within *R* - a simple demo

Here is an example of how you can create a map in *R*. It is a function to get *public* data from anywhere in the world. See help of the `getData` function in the `raster` package.


```{r, message=FALSE}
library(raster)
?getData
?raster::getData
```

Read the help to find out how we can find the country codes.

```{block, type="alert alert-success"}
> **Question 6**: What is the country code of Belgium?
```

More info about the data sets see [Global Adminstrative Areas database (GADM)](http://www.gadm.org).

```{r, eval=FALSE, message=FALSE, results='hide', echo=FALSE}
raster::getData("ISO3")
```

Now we will download the administrative boundaries of the Philippines:

```{r, eval=FALSE}
datdir <- 'data'
dir.create(datdir, showWarnings = FALSE)
adm <- raster::getData("GADM", country = "PHL",
                       level = 2, path = datdir)
plot(adm[adm$NAME_1 == "Tarlac",])
```

```{r loadrda, echo=FALSE, eval=TRUE, message=FALSE}
datdir <- 'data'
if (!file.exists(datdir)) { dir.create(datdir)}
if (!file.exists(file.path(datdir, "PHL_adm2.RData"))) {
  adm <- raster::getData("GADM", country = "PHL", level=2, path = "data/")
} else {
  load(file.path(datdir, "PHL_adm2.RData"))
  adm <- gadm
}
```

Try to understand the code below, and let us know if you have questions. Feel free to use this code as an example and use this for the exercise below.

```{r phil, eval=TRUE, warning=FALSE, fig.align='center'}
mar <- adm[adm$NAME_1 == "Marinduque",]
plot(mar, bg = "dodgerblue", axes=TRUE)
plot(mar, lwd = 10, border = "skyblue", add=TRUE)
plot(mar, col = "green4", add = TRUE)
grid()
box()
invisible(text(getSpPPolygonsLabptSlots(mar),
labels = as.character(mar$NAME_2), cex = 1.1, col = "white", font = 2))
mtext(side = 3, line = 1, "Provincial Map of Marinduque", cex = 2)
mtext(side = 1, "Longitude", line = 2.5, cex=1.1)
mtext(side = 2, "Latitude", line = 2.5, cex=1.1)
mtext(side = 1, line = -2,
"Projection: Geographic\n
Coordinate System: WGS 1984    \n
Data Source: GADM.org    ", adj = 1, cex = 0.5, col = "grey20")
```

# Exercise 1: Develop a function to create a spatial map

## Description

- Write your own function to create a spatial map for a country of **your choice** that is:
    - clearly structured,
    - reproducible by another team on their computer,
    - well documented.

- To do's with the script:
    - Define the function.
    - Demonstrate the function
    (i.e. use it to plot a map of a country and a certain level as an example).
    - The function should accept `country` and `level` as input arguments.
    
## Hints

- Keep it simple (!) e.g. just plot the administrative boundaries as the focus on it on **reproducible scripting**
- Make sure the script is **reproducible**, **structured**, and **documented** 
- Do not use any paths e.g. `mydocument/John/blabla` specific for your computer. 
- Do not set the working directory (see the above tutorial).
- Data should be downloaded via the script
- All code requires comments - explaining its functionality
- Use the script template below
    
Script template:
```{r, eval=FALSE}
# Name: Team name and members of the team
# Date: 7 January 2019

# Import packages
library(raster)
# Define the function

# An example based on that function
```

# Bonus

- Try to get the administrative labels and legend correctly set

# Submission

- Use the script review center in Black Board to submit your script by **17:15**.
- Do not use an attachment, just paste the script (note: there is a pasting bug in Internet Explorer, so use a different browser).
- Follow the file naming precisely!


```{block, type="alert alert-info"}
**Protip**: Alternatively, you can also upload your solution as a secret [GitHub Gist](https://gist.github.com/) and then paste a link to it on Black Board.
```
<!-- or a private [GitLab snippet](https://git.wur.nl/snippets/new), -->

# Peer-Reviewing

You will need to give the team you are reviewing feedback on their exercise solution **before 11:00 the next day** (use the review team generator Shiny app to see which team). 

- The teams need to use the [Generic Rubric](https://docs.google.com/document/d/1wdqcrqh4Bt-tNwhEFRa4esq7ozwo36tfOjGmbBTK5B4/edit?usp=sharing) and fill in the *form* as a guideline and copy "as text" (*not as a document or attachement*) within the blackboard box.

- The Geo-scripting team will assess the quality of the review done by each team.

The three specific tasks that will be assessed are:

1. Create a function (yes, no)
2. The function accepts minimum two inputs (`country` and `level` ), and is able to plot a map
3. The function is demonstrated with minimum one working example on how the function can be used

# References and more info

- [RStudio Online Learning](http://www.rstudio.com/resources/training/online-learning/). 
- [Coursera](https://www.coursera.org/course/rprog)

```{block, type="alert alert-info"}
# Optional: Creating documented reports

A great way to avoid clicking and copy pasting is to create a script that combines text (explanation of your script, introduction, or something else) and a R script and creates a report as an html file.

You can create an `.html` from an `.Rmd` file. Click on the following [link](https://rpubs.com/about/getting-started) for getting started and publishing your html to the web.

## RStudio

* In RStudio, create a new R Markdown document by choosing File | New | R Markdown
    * select HTML as a default output format (see screenshot)

![](figs/DefaultOutput_Format.png)

In the white parts of the R Markdown you can type anything (such as text or titles), which will not be run as a script. In the grey boxes you can type your code. Running the code can be done with the play button ("run current chunk") on the right top side of the grey box or by clicking in the RMD you can use the shortcut Ctrl + shift + enter to run the whole code chunk. This combination of text and code in R Markdown is very user friendly and makes it easy to make documents with nice visualizations or nicely documented code.

* Click the Knit HTML button in the doc toolbar to preview your document such as the assignment of today.

![](figs/KnitHTML.png)

* In the preview window, click the Publish button.

## CLI or other GUIs

R Markdown is just plain Markdown with blocks of evaluated R code, so you can use any text editor to write it. Then, in order to convert a file called `index.Rmd` into HTML, you can use R functions:

    library(knitrBootstrap)
    library(rmarkdown)
    render('index.Rmd', 'knitrBootstrap::bootstrap_document')

Then you can upload the resulting HTML file anywhere, e.g. on GitHub Pages. In fact, this is how this entire course website is made!

```

<!--
## Dataframe manipulation
This section is also just a draft and should be further elaborated
One central object class of R is the dataframes. The spatial vector classes of R are usually built around dataframes as well, as a consequence, all dataframe manipulation functions and methods are also highly relevant when dealing with spatial vector data in R.

* `str()`
* `subset()`
* `cbind()`, `rbind()`
* Methods with `[,]`, `[,] <-`
* `merge()`

# ```{r, echo=FALSE}
# df <- data.frame(x = 1:10, y = 1:10)
# ## load the googleVis package
# suppressPackageStartupMessages(library(googleVis))
# ## create the scatter chart
# sc <- gvisScatterChart(data=df,
#                         options=list(width=300, height=300, 
#                                      legend='none',
#                                      hAxis="{title:'x'}",
#                                      vAxis="{title:'y'}")
#           )
# plot(sc)
# ```
# 
# ```{r, results='asis', echo=FALSE}
# print(sc, "chart")  ## same as cat(sc$html$chart)
# ```
-->
